### @OneToOne
Specifies a single-valued association to another entity that has one-to-one multiplicity. It is not normally necessary to specify the associated target entity explicitly since it can usually be inferred from the type of the object being referenced. 

If the relationship is bidirectional, the non-owning side must use the `mappedBy` element of the `OneToOne` annotation to specify the relationship field or property of the owning side.

> 指定与具有一对一多重性的另一个实体的单值关联。通常不需要明确指定关联的目标实体，因为它通常可以从被引用对象的类型中推断出来。
>
> 如果关系是双向的，非拥有方（没有持有外键的一方）必须使用 `OneToOne` 注解的 `mappedBy` 元素来指定拥有方的关系字段或属性。

The `OneToOne` annotation may be used within an embeddable class to specify a relationship from the embeddable class to an entity class.

 If the relationship is bidirectional and the entity containing the embeddable class is on the owning side of the relationship, the non-owning side must use the `mappedBy` element of the `OneToOne` annotation to specify the relationship field or property of the embeddable class. 

The dot (".") notation syntax must be used in the `mappedBy` element to indicate the relationship attribute within the embedded attribute. The value of each identifier used with the dot notation is the name of the respective embedded field or property.

> `OneToOne` 注解可以在可嵌入类中使用，以指定从可嵌入类到实体类的关系。
>
> 如果关系是双向的，且包含可嵌入类的实体处于关系的拥有方（持有外键的一方），则非拥有方必须使用 `OneToOne` 注解的 `mappedBy` 元素来指定可嵌入类的关系字段或属性。
>
> 在`mappedBy` 元素中必须使用点（“.”）符号语法来表示嵌入属性中的关系属性。与点符号一起使用的每个标识符的值是相应嵌入字段或属性的名称。



1. Example 1: One-to-one association that maps a foreign key column. 
映射外键列的一对一关联

```java
/**
 * Customer和CustomerRecord，建立了一对一双向关联，Customer类负责维护关联关系（持有外键）,CustomerRecord通过mappedBy指定关联关系被Customer类中的customerRecord属性维护。
 * 外键列`CUSTREC_ID`在Customer表中,该列的值引用了CustomerRecord表的主键,建立两表之间的一对一关系。
 */

// On Customer class:
@OneToOne(optional=false)
@JoinColumn(
    name="CUSTREC_ID", unique=true, nullable=false, updatable=false)
public CustomerRecord getCustomerRecord() {
    return customerRecord; 
}

// On CustomerRecord class:
// mappedBy="customerRecord"表示关联关系由Customer类中的customerRecord属性维护,该属性引用了CustomerRecord。
@OneToOne(optional=false, mappedBy="customerRecord")
public Customer getCustomer() {
    return customer; 
}
```

2.  Example 2: One-to-one association that assumes both the source and target share the same primary key values. 
一对一关联，假定源和目标共享相同的主键值。

```java
/**
 * @MapsId 实现了一对一关联时双方共享同一主键,Employee和EmployeeInfo的id字段值将完全一致,实现一对一主键关联映射。
 */

// On Employee class:
@Entity
public class Employee {
    @Id 
    Integer id;
    
    @OneToOne 
    @MapsId
    EmployeeInfo info;
    //...
}

// On EmployeeInfo class:
@Entity
public class EmployeeInfo {
    @Id 
    Integer id;
    //...
}
```

3. Example 3: One-to-one association from an embeddable class to another entity.
从一个可嵌入类到另一个实体的一对一关联。

```java
@Entity
public class Employee {
    @Id 
    int id;
    
    // @Embedded 注解表示这是一个嵌入类，而不是一个单独的表。
    @Embedded 
    LocationDetails location;
    //...
}

@Embeddable
public class LocationDetails {
    int officeNumber;
    
    // 在可嵌入类中使用`OneToOne`注解，以指定从可嵌入类到实体类的关系。
    @OneToOne 
    ParkingSpot parkingSpot;
    //...
}

@Entity
public class ParkingSpot {
    @Id int id;
    String garage;
    
    // 在`mappedBy` 元素中必须使用点（“.”）符号语法来表示嵌入属性中的关系属性。与点符号一起使用的每个标识符的值是相应嵌入字段或属性的名称。
    @OneToOne(mappedBy="location.parkingSpot") 
    Employee assignedTo;
    //... 
} 
```

#### 源代码
```java
@Target({METHOD, FIELD}) 
@Retention(RUNTIME)
public @interface OneToOne {

    /** 
     * (可选）关联目标的实体类。
     * 默认为存储关联的字段或属性的类型。 
     */
    Class targetEntity() default void.class;

    /**
     * (可选）必须级联到关联目标的操作。
     * 默认情况下不会级联任何操作。
     */
    CascadeType[] cascade() default {};

    /** 
     * （可选）关联是否应延迟加载或必须急切获取。
     * EAGER 策略是对持久化提供程序运行时的要求，必须急切地获取关联实体。
     * LAZY 策略是对持久化提供程序运行时的提示。
     */
    FetchType fetch() default EAGER;

    /** 
     * (可选）关联是否可选。如果设置为 false，则非空关系必须始终存在。
     */
    boolean optional() default true;

    /** 
     * (可选）拥有该关系的字段。该元素仅在关联的反向（非拥有，不持有外键）侧指定。
     */
    String mappedBy() default "";

    /**
     * (可选）是否将移除操作应用于已从关系中移除的实体，并将移除操作级联到这些实体。
     * @since 2.0
     */
    boolean orphanRemoval() default false;
}
```

### @OneToMany
Specifies a many-valued association with one-to-many multiplicity.
> 

If the collection is defined using generics to specify the element type, the associated target entity type need not be specified; otherwise the target entity class must be specified. If the relationship is bidirectional, the mappedBy element must be used to specify the relationship field or property of the entity that is the owner of the relationship.
> 

The OneToMany annotation may be used within an embeddable class contained within an entity class to specify a relationship to a collection of entities. If the relationship is bidirectional, the mappedBy element must be used to specify the relationship field or property of the entity that is the owner of the relationship. When the collection is a java.util.Map, the cascade element and the orphanRemoval element apply to the map value.
> 

#### 源代码
```java
@Target({METHOD, FIELD}) 
@Retention(RUNTIME)

public @interface OneToMany {

    /**
     * (Optional) The entity class that is the target
     * of the association. Optional only if the collection
     * property is defined using Java generics.
     * Must be specified otherwise.
     *
     * <p> Defaults to the parameterized type of
     * the collection when defined using generics.
     */
    Class targetEntity() default void.class;

    /** 
     * (Optional) The operations that must be cascaded to 
     * the target of the association.
     * <p> Defaults to no operations being cascaded.
     *
     * <p> When the target collection is a {@link java.util.Map
     * java.util.Map}, the <code>cascade</code> element applies to the
     * map value.
     */
    CascadeType[] cascade() default {};

    /** (Optional) Whether the association should be lazily loaded or
     * must be eagerly fetched. The EAGER strategy is a requirement on
     * the persistence provider runtime that the associated entities
     * must be eagerly fetched.  The LAZY strategy is a hint to the
     * persistence provider runtime.
     */
    FetchType fetch() default LAZY;

    /** 
     * The field that owns the relationship. Required unless 
     * the relationship is unidirectional.
     */
    String mappedBy() default "";

    /**
     * (Optional) Whether to apply the remove operation to entities that have
     * been removed from the relationship and to cascade the remove operation to
     * those entities.
     * @since 2.0
     */
    boolean orphanRemoval() default false;
}
```

### @ManyToOne

#### 源代码
```java
@Target({METHOD, FIELD}) 
@Retention(RUNTIME)
public @interface ManyToOne {

    /** 
     * (Optional) The entity class that is the target of 
     * the association. 
     *
     * <p> Defaults to the type of the field or property 
     * that stores the association. 
     */
    Class targetEntity() default void.class;

    /**
     * (Optional) The operations that must be cascaded to 
     * the target of the association.
     *
     * <p> By default no operations are cascaded.
     */
    CascadeType[] cascade() default {};

    /** 
     * (Optional) Whether the association should be lazily 
     * loaded or must be eagerly fetched. The EAGER
     * strategy is a requirement on the persistence provider runtime that 
     * the associated entity must be eagerly fetched. The LAZY 
     * strategy is a hint to the persistence provider runtime.
     */
    FetchType fetch() default EAGER;

    /** 
     * (Optional) Whether the association is optional. If set 
     * to false then a non-null relationship must always exist.
     */
    boolean optional() default true;
}
```
### @ManyToMany

#### 源代码
```java
@Target({METHOD, FIELD}) 
@Retention(RUNTIME)
public @interface ManyToMany {

    /**
     * (Optional) The entity class that is the target of the
     * association. Optional only if the collection-valued
     * relationship property is defined using Java generics.  Must be
     * specified otherwise.
     *
     * <p> Defaults to the parameterized type of
     * the collection when defined using generics.
     */
    Class targetEntity() default void.class;

    /** 
     * (Optional) The operations that must be cascaded to the target
     * of the association.  
     *
     * <p> When the target collection is a {@link java.util.Map
     * java.util.Map}, the <code>cascade</code> element applies to the
     * map value.
     *
     * <p> Defaults to no operations being cascaded.
     */
    CascadeType[] cascade() default {};

    /** (Optional) Whether the association should be lazily loaded or
     * must be eagerly fetched. The EAGER strategy is a requirement on
     * the persistence provider runtime that the associated entities
     * must be eagerly fetched.  The LAZY strategy is a hint to the
     * persistence provider runtime.
     */
    FetchType fetch() default LAZY;

    /** 
     * The field that owns the relationship. Required unless 
     * the relationship is unidirectional.
     */
    String mappedBy() default "";
}
```